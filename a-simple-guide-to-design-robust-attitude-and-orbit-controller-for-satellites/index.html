<!DOCTYPE html><html lang="en-us"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>A Simple Guide to Design Robust Attitude and Orbit Controller for Satellites - Space Navigators</title><meta name="description" content="This article describes the H-infinity control applied to spacecraft AOCS."><meta name="generator" content="Publii Open-Source CMS for Static Site"><link rel="canonical" href="https://spacenavigators.com/a-simple-guide-to-design-robust-attitude-and-orbit-controller-for-satellites/"><link rel="alternate" type="application/atom+xml" href="https://spacenavigators.com/feed.xml" title="Space Navigators - RSS"><link rel="alternate" type="application/json" href="https://spacenavigators.com/feed.json" title="Space Navigators - JSON"><meta property="og:title" content="A Simple Guide to Design Robust Attitude and Orbit Controller for Satellites"><meta property="og:image" content="https://spacenavigators.com/media/posts/16/HInResults.png"><meta property="og:image:width" content="1920"><meta property="og:image:height" content="899"><meta property="og:site_name" content="Space Navigators"><meta property="og:description" content="This article describes the H-infinity control applied to spacecraft AOCS."><meta property="og:url" content="https://spacenavigators.com/a-simple-guide-to-design-robust-attitude-and-orbit-controller-for-satellites/"><meta property="og:type" content="article"><link rel="shortcut icon" href="https://spacenavigators.com/media/website/favicon_min.png" type="image/png"><link rel="stylesheet" href="https://spacenavigators.com/assets/css/style.css?v=68ebef1b1675aa1aa577c9edb366f816"><script type="application/ld+json">{"@context":"http://schema.org","@type":"Article","mainEntityOfPage":{"@type":"WebPage","@id":"https://spacenavigators.com/a-simple-guide-to-design-robust-attitude-and-orbit-controller-for-satellites/"},"headline":"A Simple Guide to Design Robust Attitude and Orbit Controller for Satellites","datePublished":"2025-11-30T12:31+01:00","dateModified":"2025-11-30T13:47+01:00","image":{"@type":"ImageObject","url":"https://spacenavigators.com/media/posts/16/HInResults.png","height":899,"width":1920},"description":"This article describes the H-infinity control applied to spacecraft AOCS.","author":{"@type":"Person","name":"Yajur Kumar","url":"https://spacenavigators.com/authors/yajur-kumar/"},"publisher":{"@type":"Organization","name":"Yajur Kumar","logo":{"@type":"ImageObject","url":"https://spacenavigators.com/media/website/globeandaroundmini.PNG","height":167,"width":601}}}</script><noscript><style>img[loading] {
                    opacity: 1;
                }</style></noscript><script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script><script>MathJax = {
    tex: {
      inlineMath: [['$$', '$$'], ['\\(', '\\)']],
      displayMath: [['\\[', '\\]']],
    }
  };</script></head><body class="post-template"><script>MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      displayMath: [['$$', '$$'], ['\\[', '\\]']]
    },
    svg: {
      fontCache: 'global'
    }
  };</script><script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js" async></script><header class="top js-header"><a class="logo" href="https://spacenavigators.com/"><img src="https://spacenavigators.com/media/website/globeandaroundmini.PNG" alt="Space Navigators" width="601" height="167"></a><nav class="navbar js-navbar"><button class="navbar__toggle js-toggle" aria-label="Menu" aria-haspopup="true" aria-expanded="false"><span class="navbar__toggle-box"><span class="navbar__toggle-inner">Menu</span></span></button><ul class="navbar__menu"><li><a href="https://spacenavigators.com/articles/" title="Download Articles" target="_self">Download Articles</a></li><li><a href="https://spacenavigators.com/about-me/" target="_self">About Me</a></li><li><a href="https://spacenavigators.com/resume/" target="_blank">Resume</a></li></ul></nav><div class="search"><div class="search__overlay js-search-overlay"><div class="wrapper search__overlay-inner"></div></div><button class="search__btn btn--icon js-search-btn" aria-label="Search"><svg height="18" width="18" role="presentation" focusable="false"><use xlink:href="https://spacenavigators.com/assets/svg/svg-map.svg#search"/></svg></button></div></header><main class="post"><article class="content"><div class="hero"><header class="hero__content"><div class="wrapper"><h1>A Simple Guide to Design Robust Attitude and Orbit Controller for Satellites</h1><div class="feed__meta content__meta"><a href="https://spacenavigators.com/authors/yajur-kumar/" class="feed__author">Yajur Kumar</a> <time datetime="2025-11-30T12:31" class="feed__date">November 30, 2025</time></div></div></header><figure class="hero__image"><div class="hero__image-wrapper"><img src="https://spacenavigators.com/media/posts/16/HInResults.png" srcset="https://spacenavigators.com/media/posts/16/responsive/HInResults-xs.png 640w, https://spacenavigators.com/media/posts/16/responsive/HInResults-sm.png 768w, https://spacenavigators.com/media/posts/16/responsive/HInResults-md.png 1024w, https://spacenavigators.com/media/posts/16/responsive/HInResults-lg.png 1366w, https://spacenavigators.com/media/posts/16/responsive/HInResults-xl.png 1600w, https://spacenavigators.com/media/posts/16/responsive/HInResults-2xl.png 1920w" sizes="88vw" loading="eager" height="899" width="1920" alt=""></div></figure></div><div class="entry-wrapper content__entry"><p>My usual approach to learn a new system involves learning about its history and how it came into existence. Today we are exploring the robust controllers used in the satellites.</p><h3 id="some-interesting-history">Some Interesting History</h3><p>Early satellites from the 1950s and 60s, such as Explorer 1 and Vanguard, relied on simple attitude control methods to keep the spacecraft stable and correctly aligned which was done often using passive stabilization through spin mechanics or basic magnetic torquers. These methods worked well for the lightweight spacecraft of that era, but as missions grew more complex, the need for better control systems increased.</p><p>Coming to the 1970s and 80s, we had scientific missions like Skylab, Viking, and Voyager needed precise pointing for imaging, communication, and navigation. This turned attention to closed-loop feedback control, which used reaction wheels, star trackers, and gyroscopes. Conventional control methods, such as PID loops, decoupled axis controllers, and gain-scheduled linear controllers, became standard in spacecraft Attitude and Orbit Control Systems (AOCS). These controllers worked well under normal conditions, but they had a significant drawback. As missions became more complex, spacecraft dynamics revealed strong couplings, flexible vibrations, actuator nonlinearities, and major uncertainties. Traditional controllers struggled to ensure stability or performance when the spacecraft deviated from established models.</p><p>By the 1980s, the limits of traditional control theory were clear with the rise of large flexible spacecraft, deployable structures, and highly accurate Earth-observing satellite constellations. This led to a focus on control methods aimed at not just improving performance but also maintaining stability in light of modeling errors, disturbances, and worst-case scenarios. Organizations like NASA and ESA began to test these methods on projects such as the Hubble Space Telescope, ENVISAT, and various technology demonstrations.</p><p>Leading this change was H∞ (H-infinity) control, a concept that rapidly evolved throughout the 1990s. Unlike controllers based on exact models, H∞ includes structured uncertainty, disturbance management, and worst-case scenario handling directly in the design. This approach is particularly useful for satellites facing environmental torques, shifting mass properties due to fuel burnoff, flexible solar arrays, or issues with reaction wheels. In the following decades, H∞ control, along with robust methods like μ-synthesis LQG/LTR and gain-scheduling with robustness margins, became critical elements in advanced AOCS design.</p><p>Today, as spacecraft grow larger, more agile, and increasingly autonomous—from mega-constellation satellites to interplanetary probes—it is required to make the AOCS robust to various operational conditions. They form the basis of AOCS design, allowing satellites to maintain stability and functionality amid the many uncertainties found in the challenging space environment.</p><p>In the following blog, I will show how H∞ control can be applied to a typical AOCS problem, demonstrating its ability to provide reliable closed-loop performance even with considerable model uncertainties and external disturbances.</p><hr><h3 id="some-mathematics">Some Mathematics</h3><p>Here is some mathematical background that will come in handy.</p><h4 id="system-norms">System Norms</h4><ul><li>$H_2$ Norm: Root mean square value of the output for white noise input.</li><li>$H_∞$ Norm: Worst-case energy amplification from input to output.</li></ul><p>$$ ||G(s)||_∞ = max_ω σ̄(G(jω)) $$ where $σ̄ $ is the maximum singular value.</p><h4 id="the-small-gain-theorem">The Small Gain Theorem</h4><p>A feedback system stays stable if:<br>$$ ||Δ(s)||_∞ · ||T(s)||_∞ &lt; 1 $$ where $Δ$ represents uncertainty and $T$ is the complementary sensitivity.</p><h4 id="mixed-sensitivity-problem">Mixed Sensitivity Problem</h4><p>The standard $H_∞$ problem minimizes:<br>$$ || \begin{matrix} W_p S ,\ W_u K S ,\ W_T T \end{matrix} ||_∞ $$</p><p>where:</p><p>$S$ = Sensitivity function $(I + GK)^{-1}$</p><p>$T$ = Complementary sensitivity $I - S$</p><p>$W_p$ = Performance weight</p><p>$W_u$ = Control effort weight</p><p>$W_T$ = Robustness weight</p><hr><h3 id="a-little-context">A Little Context</h3><p>Let’s design an Attitude and Orbit Control System (AOCS) for a large, flexible communication satellite (it has kind of large solar arrays!) in Geostationary Orbit (GEO). This application suits H∞ well due to the complex and high-fidelity dynamics. In general, there are various modes of control in the AOCS for satellite, and generally, the kind of mode depends on what the actual objective of the particular mode.</p><h3 id="step-1-mathematical-modeling">Step 1: Mathematical Modeling</h3><h4 id="satellite-rigid-body-dynamics">Satellite Rigid Body Dynamics</h4><p>Let’s keep it simple and we have the usual torque-inertia equation: $$ Jω̇ + ω × Jω = τ_{ctrl} + τ_{dist} $$</p><p>where:</p><ul><li>$J$ = Inertia tensor</li><li>$ω$ = Angular velocity vector</li><li>$τ_{ctrl}$ = Control torque</li><li>$τ_{dist}$ = Disturbance torque</li></ul><h5 id="flexible-mode-dynamics">Flexible Mode Dynamics</h5><p>The solar arrays are not rigid. They have bending and twisting modes. This is modeled by adding modal coordinates. Let’s consider $N$ flexible modes: $$ [J, \Gamma; \Gamma^T, I ] [\dot\omega, \ddot\eta ]+… = [\tau_{ctrl};0 ] $$ where:</p><ul><li>$η$ = Flexible mode coordinates</li><li>$Γ$ = Rigid-flex coupling matrix (coupling between rigid and flexible motion)</li><li>$Ω$ = Flexible mode frequency matrix</li><li>$ζ$ = Damping ratio matrix</li></ul><h5 id="actuator-dynamics">Actuator Dynamics</h5><p>Here, for this example, let’s consider we have reaction wheen as the only actuator. Reaction wheels have a maximum torque/speed limit and are modeled with a first-order lag: $$\frac{1}{0.02s+1} $$</p><h5 id="sensor-dynamics">Sensor Dynamics</h5><p>Star trackers and gyros have noise and delays. The star tracker might have a low-pass characteristic and a processing delay of more or less 100ms.</p><h3 id="step-2-control-objectives-and-uncertainty">Step 2: Control Objectives and Uncertainty</h3><ul><li>High-Performance Pointing: Track a commanded attitude (for example, from a ground station) with an error of less than 0.001° (RMS).</li><li>Vibration Suppression: Actively dampen the vibrations of the solar arrays to avoid blurring of onboard optical payloads.</li><li>Manage Control Effort: Do not overwork the reaction wheels.</li><li>Robustness: Keep stability and performance despite:</li><li>Parametric Uncertainty: Mass properties (J) change as fuel is used. Payloads can be deployed, which alters the inertia.<br>Mass uncertainty: $$ m_{real} = m_{nom} × (1 + δ_m), $$ where, $ |δ_m| ≤ 0.2 $ Flexible mode frequency uncertainty: $$ ω_{real} = ω_{nom} × (1 + δ_ω), $$ where, $ |δ_ω| ≤ 0.3 $</li><li>Dynamic Uncertainty: The exact frequency and damping of the flexible modes are unknown and can vary with temperature. We might only know that a mode falls between 0.8 Hz and 1.2 Hz.<br>Multiplicative uncertainty representation: $$ G_{real}(s) = G_{nom}(s)(1 + W_Δ(s)Δ(s)) $$ where, $||Δ(s)||_∞ ≤ 1$</li><li>Unmodeled Dynamics: There are higher-order flexible modes beyond the six we modeled.</li></ul><p>I can tabulate below them as well:</p><table><thead><tr><th>Objective</th><th>Mathematical Representation</th><th>Physical Meaning</th></tr></thead><tbody><tr><td><strong>Precise Pointing</strong></td><td>Minimize tracking error</td><td>Maintain payload alignment</td></tr><tr><td><strong>Disturbance Rejection</strong></td><td>Minimize $||S||_∞$</td><td>Resist environmental torques</td></tr><tr><td><strong>Control Effort Management</strong></td><td>Minimize $||KS||_∞$</td><td>Prevent actuator saturation</td></tr><tr><td><strong>Robust Stability</strong></td><td>Minimize $||T||_∞$</td><td>Handle model uncertainties</td></tr><tr><td><strong>Flexible Mode Damping</strong></td><td>Shape loop gain around flexible frequencies</td><td>Suppress solar array vibrations</td></tr></tbody></table><h3 id="step-3-setting-up-the-h∞-control-design">Step 3: Setting up the H∞ Control Design</h3><p>Let’s formulate this as mixed sensitivity H∞ problem, where we are required to define the generalized plant with weights. Well, the performance, control and uncertainty weights are described below.</p><ul><li>Performance Weight ($W_p$): It is based on the tracking error, $e = θ_{ref} - θ$. It is high at low frequencies to ensure good tracking and decreases at high frequencies.</li><li>Control Effort Weight ($W_u$): This is applied to the control signal u (wheel commands). It is low at low frequencies to permit control action and increases at high frequencies to stop the controller from triggering high-frequency unmodeled dynamics.</li><li>Uncertainty Weight ($W_Δ$): This is used to handle the flexible mode uncertainty. We apply a high-pass filter shape that is small at low frequencies, where our model performs well, and large at high frequencies, where the model does not perform as well. And, finally as described above the controller gain $K(s)$ is synthesized by minimizing: $$ || \begin{matrix} W_p S ,\ W_u K S ,\ W_T T \end{matrix} ||_∞ $$</li></ul><p>Minimizing this norm directly balances performance, control effort, and robustness.</p><hr><h3 id="controller-design-process">Controller Design Process</h3><h4 id="state-space-representation">State-Space Representation</h4><p>The system can be represented in the state-space form as:</p><pre><code class="language-matlab">% System matrices for n flexible modes
A = [0         I         0         0;
     -K_rigid  -D_rigid  -K_coup   0;
     0         0         0         I;
     -K_coup&#39;  0         -K_flex   -D_flex];
     
B = [0; I; 0; gamma&#39;];
C = [I 0 0 0];  % Attitude measurement
</code></pre><h4 id="step-1-system-identification">Step 1: System Identification</h4><h4 id="parameter-estimation">Parameter Estimation</h4><pre><code class="language-matlab">% Nominal parameters
J_nom = diag([1000, 800, 1200]);  % kg·m²
freq_modes = [0.8, 2.5, 5.0];     % Hz
damping_ratio = 0.01;             % 1% damping
</code></pre><h4 id="model-construction">Model Construction</h4><pre><code class="language-matlab">% Build state-space model with flexible modes
n_states = 2 + 2 * length(freq_modes);
[A, B, C, D] = buildFlexibleSatelliteModel(J_nom, freq_modes, damping_ratio);
sat_plant = ss(A, B, C, D);
</code></pre><h4 id="step-2-weight-selection">Step 2: Weight Selection</h4><h5 id="performance-weight-w_p">Performance Weight (W_p)</h5><pre><code class="language-matlab">s = tf(&#39;s&#39;);
W_perf = 0.1 * (s/0.1 + 1)/(s/10 + 1);
</code></pre><p><strong>Recall, characteristics:</strong></p><ul><li>High gain at low frequencies for good tracking</li><li>Roll-off at high frequencies to avoid high-frequency noise amplification</li></ul><h5 id="control-effort-weight-w_u">Control Effort Weight (W_u)</h5><pre><code class="language-matlab">W_control = 0.01 * (s/5 + 1)/(s/0.5 + 1);
</code></pre><p><strong>Recall, purpose:</strong> Penalize large control inputs to prevent actuator saturation</p><h5 id="robustness-weight-w_t">Robustness Weight (W_T)</h5><pre><code class="language-matlab">W_robust = 0.3 * (s/1 + 1)/(s/10 + 1);
</code></pre><p><strong>Recall, role:</strong> Shape complementary sensitivity for robustness to high-frequency uncertainties</p><h4 id="step-3-generalized-plant-construction">Step 3: Generalized Plant Construction</h4><pre><code class="language-matlab">systemnames = &#39;P W_perf W_control W_robust&#39;;
inputvar = &#39;[w; u]&#39;;
outputvar = &#39;[W_perf; W_control; W_robust; e]&#39;;
input_to_P = &#39;[u + w]&#39;;
input_to_W_perf = &#39;[e]&#39;;
input_to_W_control = &#39;[u]&#39;;
input_to_W_robust = &#39;[P]&#39;;

P_gen = sysic;
</code></pre><h4 id="step-4-h-infinity-synthesis">Step 4: H-Infinity Synthesis</h4><pre><code class="language-matlab">[K, ~, gamma] = hinfsyn(P_gen, nmeas, ncont);
</code></pre><p><strong>Algorithm Steps:</strong></p><ol><li>Solve two Riccati equations</li><li>Check existence conditions</li><li>Construct controller state-space matrices</li><li>Verify achieved performance level $γ$</li></ol><h4 id="step-5-controller-reduction">Step 5: Controller Reduction</h4><pre><code class="language-matlab">if order(K) &gt; 8
    K_red = reduce(K, 8);  % Reduce to manageable order
end
</code></pre><h3 id="implementation-in-matlab">Implementation in MATLAB</h3><h4 id="complete-design-code-structure">Complete Design Code Structure</h4><pre><code class="language-matlab">%% AOCS H-Infinity Design Pipeline
% 1. System Modeling
[A, B, C, D] = buildSatelliteModel(parameters);
P = ss(A, B, C, D);

% 2. Weight Selection  
[W_perf, W_control, W_robust] = designWeights(requirements);

% 3. Generalized Plant
P_gen = buildGeneralizedPlant(P, W_perf, W_control, W_robust);

% 4. Controller Synthesis
[K, gamma] = synthesizeHinfController(P_gen);

% 5. Validation
[pass, margins] = validateDesign(P, K, requirements);
</code></pre><h4 id="stability-margin-enforcement">Stability Margin Enforcement</h4><pre><code class="language-matlab">function [K_optimal, design_info] = synthesizeAOCSController(P_plant, requirements, max_iterations)
    % Iterative synthesis with margin enforcement
    for iter = 1:max_iterations
        % H-infinity synthesis
        [K, ~, gamma] = hinfsyn(P_gen, 1, 1);
        
        % Check margins against requirements
        [pass, margins] = checkStabilityMargins(P_plant*K, requirements);
        
        if pass &amp;&amp; margins.meets_target
            break;  % Requirements satisfied
        else
            % Adjust weights and iterate
            [W_perf, W_control] = adjustWeights(margins, requirements);
        end
    end
end
</code></pre><h3 id="performance-analysis">Performance Analysis</h3><h4 id="stability-margins-analysis">Stability Margins Analysis</h4><h4 id="industry-standards">Industry Standards</h4><p>When I say industry standards, I mean the “typical” values being used at ISRO (from my experience), at NASA and ESA (from their respective reference documents). What stability margins will fit to your needs depends on your objective.</p><table><thead><tr><th>Mission Type</th><th>Gain Margin</th><th>Phase Margin</th><th>Flexible Mode GM</th><th>Flexible Mode PM</th></tr></thead><tbody><tr><td>Conservative</td><td>≥ 8 dB</td><td>≥ 45°</td><td>≥ 6 dB</td><td>≥ 30°</td></tr><tr><td>Typical</td><td>≥ 6 dB</td><td>≥ 35°</td><td>≥ 4 dB</td><td>≥ 25°</td></tr><tr><td>Aggressive</td><td>≥ 4 dB</td><td>≥ 25°</td><td>≥ 3 dB</td><td>≥ 20°</td></tr><tr><td>Human-Rated</td><td>≥ 12 dB</td><td>≥ 60°</td><td>≥ 9 dB</td><td>≥ 45°</td></tr></tbody></table><h4 id="margin-calculation">Margin Calculation</h4><pre><code class="language-matlab">function [pass, margin_info] = checkStabilityMargins(L, requirements)
    [GM, PM, Wcg, Wcp] = margin(L);
    GM_db = 20*log10(GM);
    
    % Check against requirements
    pass_GM = GM_db &gt;= requirements.GM_min;
    pass_PM = PM &gt;= requirements.PM_min;
    
    % Flexible mode margins
    for i = 1:length(flexible_freqs)
        [mag, phase] = bode(L, 2*pi*flexible_freqs(i));
        % Calculate effective margins at each flexible mode
    end
end
</code></pre><h4 id="time-domain-performance">Time Domain Performance</h4><h5 id="step-response-specifications">Step Response Specifications</h5><p>Again, these are “typical” values, and as per your objective, they can vary:</p><ul><li><strong>Rise Time</strong>: &lt; 30 seconds for large maneuvers</li><li><strong>Settling Time</strong>: &lt; 60 seconds to 2% of final value</li><li><strong>Overshoot</strong>: &lt; 10% for most missions</li><li><strong>Steady-State Error</strong>: &lt; 0.001° for precision pointing</li></ul><h5 id="disturbance-rejection">Disturbance Rejection</h5><pre><code class="language-matlab">% Disturbance to output transfer function
T_dist = P / (1 + P*K);
% Analyze impulse response for disturbance rejection capability
</code></pre><h4 id="frequency-domain-analysis">Frequency Domain Analysis</h4><h5 id="sensitivity-functions">Sensitivity Functions</h5><ul><li><strong>S(jω)</strong>: Tracking error to reference</li><li><strong>T(jω)</strong>: Output to reference (complementary sensitivity)</li><li><strong>KS(jω)</strong>: Control effort to reference</li></ul><h5 id="loop-shaping-requirements">Loop Shaping Requirements</h5><pre><code class="language-matlab">% Desired loop shape characteristics
w_gc = 0.1;  % Gain crossover frequency [rad/s]
slope_near_gc = -20;  % dB/decade near crossover
high_freq_rolloff = -40;  % dB/decade at high frequency
</code></pre><h5 id="industry-standards-1">Industry Standards</h5><h6 id="nasa-standards">NASA Standards</h6><ul><li><strong>Minimum Gain Margin</strong>: 6 dB</li><li><strong>Minimum Phase Margin</strong>: 30°</li><li><strong>Recommended Margins</strong>: 10 dB GM, 45° PM</li><li><strong>Stability Verification</strong>: Required with 20% parameter variations</li></ul><h6 id="esa-standards">ESA Standards</h6><ul><li><strong>Stability Margins</strong>: 6 dB GM, 30° PM minimum</li><li><strong>Robustness</strong>: Must tolerate ±20% parameter variations</li><li><strong>Performance</strong>: Meet specifications with 3σ dispersion These conservative margins ensure that even with unmodeled dynamics, parameter variations, and nonlinearities, the AOCS remains stable throughout the mission lifetime.</li></ul><h4 id="design-validation-process">Design Validation Process</h4><h5 id="nominal-performance">Nominal Performance</h5><pre><code class="language-matlab">% Step response analysis
step_info = stepinfo(T_cl);
fprintf(&#39;Rise Time: %.2f s\n&#39;, step_info.RiseTime);
fprintf(&#39;Settling Time: %.2f s\n&#39;, step_info.SettlingTime);
fprintf(&#39;Overshoot: %.1f%%\n&#39;, step_info.Overshoot);
</code></pre><h5 id="robustness-analysis">Robustness Analysis</h5><pre><code class="language-matlab">% Monte Carlo analysis with parameter variations
for mc_iter = 1:100
    % Perturb parameters within uncertainty bounds
    J_pert = J_nom .* (1 + 0.2*(2*rand(3,3)-1));
    % Test stability with perturbed model
    [is_stable, margins] = checkStability(perturbed_system);
end
</code></pre><h5 id="flexible-mode-excitation">Flexible Mode Excitation</h5><pre><code class="language-matlab">% Test controller response to flexible mode frequencies
for i = 1:length(flexible_freqs)
    t = 0:0.01:10;
    u_excite = 0.1 * sin(2*pi*flexible_freqs(i) * t);
    response = lsim(T_cl, u_excite, t);
    % Check that flexible modes are adequately damped
end
</code></pre><hr><h3 id="and-i-am-done-writing-for-the-day">and, I am done writing for the day!</h3><p>The results of this simple design are below for you to see:</p><pre><code class="language-matlab">Mission Type: conservative
Controller Order: 8
Stability Margins:
  Gain Margin:  17.53 dB (Required: ≥ 8.0 dB)
  Phase Margin: 81.71° (Required: ≥ 45.0°)
Performance Metrics:
  Rise Time:    20.026 s
  Settling Time: 28.658 s
  Overshoot:    0.00 %
  Peak Torque:  1.4121 Nm
</code></pre></div><footer class="content__footer"><div class="entry-wrapper"><p class="content__updated">This article was updated on November 30, 2025</p><div class="content__actions"><ul class="content__tag"><li><a href="https://spacenavigators.com/tags/aocs/">AOCS</a></li><li><a href="https://spacenavigators.com/tags/gnc/">GNC</a></li><li><a href="https://spacenavigators.com/tags/h-infinity-control/">H-infinity Control</a></li><li><a href="https://spacenavigators.com/tags/robust-control/">Robust Control</a></li></ul><div class="content__share"><button class="btn--icon content__share-button js-content__share-button"><svg width="20" height="20" aria-hidden="true"><use xlink:href="https://spacenavigators.com/assets/svg/svg-map.svg#share"></use></svg> <span>Share It</span></button><div class="content__share-popup js-content__share-popup"><a href="https://www.facebook.com/sharer/sharer.php?u=https%3A%2F%2Fspacenavigators.com%2Fa-simple-guide-to-design-robust-attitude-and-orbit-controller-for-satellites%2F" class="js-share facebook" rel="nofollow noopener noreferrer"><svg class="icon" aria-hidden="true" focusable="false"><use xlink:href="https://spacenavigators.com/assets/svg/svg-map.svg#facebook"/></svg> <span>Facebook</span> </a><a href="https://twitter.com/intent/tweet?url=https%3A%2F%2Fspacenavigators.com%2Fa-simple-guide-to-design-robust-attitude-and-orbit-controller-for-satellites%2F&amp;via=%40YajurKumar&amp;text=A%20Simple%20Guide%20to%20Design%20Robust%20Attitude%20and%20Orbit%20Controller%20for%20Satellites" class="js-share twitter" rel="nofollow noopener noreferrer"><svg class="icon" aria-hidden="true" focusable="false"><use xlink:href="https://spacenavigators.com/assets/svg/svg-map.svg#twitter"/></svg> <span>Twitter</span> </a><a href="https://www.linkedin.com/sharing/share-offsite/?url=https%3A%2F%2Fspacenavigators.com%2Fa-simple-guide-to-design-robust-attitude-and-orbit-controller-for-satellites%2F" class="js-share linkedin" rel="nofollow noopener noreferrer"><svg class="icon" aria-hidden="true" focusable="false"><use xlink:href="https://spacenavigators.com/assets/svg/svg-map.svg#linkedin"/></svg> <span>LinkedIn</span></a></div></div></div><div class="content__bio bio"><div><h3 class="h4 bio__name"><a href="https://spacenavigators.com/authors/yajur-kumar/" rel="author">Yajur Kumar</a></h3><div class="bio__desc"><p><a href="https://spacenavigators.com/about-me/">About Me</a></p></div></div></div></div><nav class="content__nav"><div class="wrapper"><div class="content__nav-inner"><div class="content__nav-prev"><a href="https://spacenavigators.com/the-three-body-problem/" class="content__nav-link" rel="prev"><div><span>Previous</span> The Three-Body Problem</div></a></div></div></div></nav></footer></article></main><footer class="footer footer--glued"><div class="wrapper"><div class="footer__copyright"><p>(C) Space Navigators, 2025. All rights reserved.</p></div><div class="footer__social"><a href="https://www.linkedin.com/company/93378143" aria-label="LinkedIn"><svg><use xlink:href="https://spacenavigators.com/assets/svg/svg-map.svg#linkedin"/></svg></a></div><button id="backToTop" class="footer__bttop" aria-label="Back to top" title="Back to top"><svg width="20" height="20"><use xlink:href="https://spacenavigators.com/assets/svg/svg-map.svg#toparrow"/></svg></button></div></footer><script defer="defer" src="https://spacenavigators.com/assets/js/scripts.min.js?v=700105c316933a8202041b6415abb233"></script><script>window.publiiThemeMenuConfig={mobileMenuMode:'sidebar',animationSpeed:300,submenuWidth: 'auto',doubleClickTime:500,mobileMenuExpandableSubmenus:true,relatedContainerForOverlayMenuSelector:'.top'};</script><script>var images = document.querySelectorAll('img[loading]');
        for (var i = 0; i < images.length; i++) {
            if (images[i].complete) {
                images[i].classList.add('is-loaded');
            } else {
                images[i].addEventListener('load', function () {
                    this.classList.add('is-loaded');
                }, false);
            }
        }</script></body></html>